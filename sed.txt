Ù…Ø±Ø­Ø¨Ø§ Ø¨Ùƒ ÙƒÙŠÙ Ù„Ù‚Ø¯ Ø§Ø¶Ù Ø¨Ø¹Ø¶ Ø§Ù„ØªØ¹Ø¯ÙŠÙ„Ø§Øª Ø¹Ù„Ø© Ø§Ù„Ù…Ø´Ø±ÙˆØ¹

Ø­ÙŠØ« Ù‚Ù…Øª Ø¨Ø§Ø¶Ø§ÙØ© 
utlis/customResponce.js
// response.js
export class ResponseStatus {
  static OK = { code: 200, status: "OK", success: true };
  static RESOURCE_CREATED = {
    code: 201,
    status: "RESOURCE_CREATED",
    success: true,
  };
  static BAD_REQUEST = { code: 400, status: "BAD_REQUEST", success: false };
  static UNAUTHORIZED = { code: 401, status: "UNAUTHORIZED", success: false };
  static FORBIDDEN = { code: 403, status: "FORBIDDEN", success: false };
  static NOT_FOUND = { code: 404, status: "NOT_FOUND", success: false };
  static INTERNAL_SERVER_ERROR = {
    code: 500,
    status: "INTERNAL_SERVER_ERROR",
    success: false,
  };
}

export class CustomResponse {
  constructor(status, message, data, error) {
    this.status = status;
    this.message = message;
    this.data = data;
    this.error = error;
  }
}

Ùˆ prisma.schema Ø§Ù„ØªÙŠ Ù„Ø¯ÙŠ Ø§ØµØ¨Ø­Øª
generator client {
  provider = "prisma-client-js"
}

datasource db {
  provider = "mysql"
  url      = env("DATABASE_URL")
}

// ===== ENUMS =====
enum Role {
  CUSTOMER
  ADMIN
  SELLER // ğŸ‘ˆ Ø®ÙŠØ§Ø± Ø¥Ø¶Ø§ÙÙŠ Ù„Ùˆ ØªÙˆØ³Ø¹Øª Ù„Ù…Ø§Ø±ÙƒØª Ø¨Ù„ÙŠØ³
}

enum OrderStatus {
  PENDING
  PAID
  SHIPPED
  DELIVERED // ğŸ‘ˆ Ø§Ù„Ø·Ù„Ø¨ ÙˆØµÙ„ Ù„Ù„Ù…Ø³ØªØ®Ø¯Ù…
  COMPLETED // ğŸ‘ˆ Ø¨Ø¹Ø¯ Ø§Ù†ØªÙ‡Ø§Ø¡ ÙØªØ±Ø© Ø§Ù„Ø¥Ø±Ø¬Ø§Ø¹/Ø¥ØºÙ„Ø§Ù‚ Ø§Ù„Ø·Ù„Ø¨
  CANCELED
  RETURNED
}

enum PaymentStatus {
  PENDING
  SUCCESS
  FAILED
  REFUNDED
  DISPUTED
}

enum PaymentMethod {
  CREDIT_CARD
  PAYPAL
  BANK_TRANSFER
  COD // ğŸ‘ˆ Ø§Ù„Ø¯ÙØ¹ Ø¹Ù†Ø¯ Ø§Ù„Ø§Ø³ØªÙ„Ø§Ù…
}

enum PaymentProvider {
  STRIPE
  PAYPAL
  BANK
  COD
}

// ===== MODELS =====
// model User {
//   id        Int       @id @default(autoincrement())
//   name      String
//   email     String    @unique
//   password  String
//   role      Role      @default(CUSTOMER)
//   createdAt DateTime  @default(now())
//   addresses Address[]
//   orders    Order[]
//   cart      Cart?
// }

model User {
  id        Int      @id @default(autoincrement())
  name      String
  email     String   @unique
  password  String
  role      Role     @default(CUSTOMER)
  createdAt DateTime @default(now())
  isVerified       Boolean   @default(false)
  verificationToken String? 
  verificationTokenExpires DateTime? 
  resetPasswordToken String?
  resetPasswordExpires DateTime?

  addresses Address[]
  orders    Order[]
  cart      Cart?
  wishlist  Wishlist[] // ğŸ‘ˆ back relation
  reviews   Review[]   // ğŸ‘ˆ Ø§Ù„Ø¹Ù„Ø§Ù‚Ø© Ø§Ù„Ø¹ÙƒØ³ÙŠØ© Ù…Ø¹ Review
}

model Address {
  id         Int    @id @default(autoincrement())
  user       User   @relation(fields: [userId], references: [id], onDelete: Cascade)
  userId     Int
  street     String
  city       String
  country    String
  postalCode String
}

model Category {
  id          Int       @id @default(autoincrement())
  name        String    @unique
  description String?
  products    Product[]
}

// model Product {
//   id          Int       @id @default(autoincrement())
//   title       String
//   slug        String    @unique
//   description String?
//   price       Decimal   @db.Decimal(10,2)
//   stock       Int       @default(0)
//   createdAt   DateTime  @default(now())
//   category    Category? @relation(fields: [categoryId], references: [id], onDelete: SetNull)
//   categoryId  Int?
//   orderItems  OrderItem[]
//   cartItems   CartItem[]

//   @@index([categoryId])
//   @@index([slug])
// }

model Review {
  id        Int      @id @default(autoincrement())
  rating    Int      // Ù…Ù† 1 Ø¥Ù„Ù‰ 5
  comment   String?
  createdAt DateTime @default(now())
  updatedAt DateTime @updatedAt

  // Ø§Ù„Ø¹Ù„Ø§Ù‚Ø§Øª
  product   Product  @relation(fields: [productId], references: [id])
  productId Int

  user      User     @relation(fields: [userId], references: [id])
  userId    Int
  // ÙŠÙ…Ù†Ø¹ Ø§Ù„Ù…Ø³ØªØ®Ø¯Ù… Ù…Ù† ÙƒØªØ§Ø¨Ø© Ø£ÙƒØ«Ø± Ù…Ù† Ù…Ø±Ø§Ø¬Ø¹Ø© Ù„Ù†ÙØ³ Ø§Ù„Ù…Ù†ØªØ¬
  @@unique([productId, userId])
} 


model Product {
  id          Int      @id @default(autoincrement())
  title       String
  slug        String   @unique
  description String?
  price       Decimal  @db.Decimal(10, 2)
  stock       Int      @default(0)
  images      ProductImage[]  // Ø¹Ù„Ø§Ù‚Ø© Ù…Ø¹ Ø§Ù„ØµÙˆØ±
  createdAt   DateTime @default(now())

  category   Category? @relation(fields: [categoryId], references: [id], onDelete: SetNull)
  categoryId Int?

  reviews     Review[]  // ğŸ‘ˆ Ø±Ø¨Ø· Ù…Ø¹ Ø§Ù„Ù…Ø±Ø§Ø¬Ø¹Ø§Øª
  avgRating   Float     @default(0) // Ù…ØªÙˆØ³Ø· Ø§Ù„ØªÙ‚ÙŠÙŠÙ…

  orderItems OrderItem[]
  cartItems  CartItem[]
  wishlist   Wishlist[] // ğŸ‘ˆ back relation

  @@index([categoryId])
  @@index([slug])
}

model ProductImage {
  id        Int     @id @default(autoincrement())
  url       String  // Ø±Ø§Ø¨Ø· Ø§Ù„ØµÙˆØ±Ø© Ù…Ù† Cloudinary
  productId Int
  product   Product @relation(fields: [productId], references: [id], onDelete: Cascade)
}

model Cart {
  id        Int        @id @default(autoincrement())
  user      User       @relation(fields: [userId], references: [id], onDelete: Cascade)
  userId    Int        @unique
  createdAt DateTime   @default(now())
  updatedAt DateTime   @updatedAt
  items     CartItem[]
}

model CartItem {
  id        Int     @id @default(autoincrement())
  cart      Cart    @relation(fields: [cartId], references: [id], onDelete: Cascade)
  cartId    Int
  product   Product @relation(fields: [productId], references: [id], onDelete: Cascade)
  productId Int
  quantity  Int     @default(1)

  @@unique([cartId, productId])
}

model Order {
  id            Int            @id @default(autoincrement())
  user          User           @relation(fields: [userId], references: [id], onDelete: Cascade)
  userId        Int
  totalAmount   Decimal        @db.Decimal(10, 2)
  status        OrderStatus    @default(PENDING)
  paymentMethod PaymentMethod?
  createdAt     DateTime       @default(now())
  items         OrderItem[]
  payment       Payment?

  @@index([userId])
  @@index([status])
}

model OrderItem {
  id        Int     @id @default(autoincrement())
  order     Order   @relation(fields: [orderId], references: [id], onDelete: Cascade)
  orderId   Int
  product   Product @relation(fields: [productId], references: [id], onDelete: Restrict)
  productId Int
  quantity  Int
  price     Decimal @db.Decimal(10, 2)
}

model Payment {
  id            Int             @id @default(autoincrement())
  order         Order           @relation(fields: [orderId], references: [id], onDelete: Cascade)
  orderId       Int             @unique
  provider      PaymentProvider
  transactionId String?         @unique
  status        PaymentStatus   @default(PENDING)
  createdAt     DateTime        @default(now())

  @@index([status])
}

// model Wishlist {
//   id        Int      @id @default(autoincrement())
//   user      User     @relation(fields: [userId], references: [id], onDelete: Cascade)
//   userId    Int
//   product   Product  @relation(fields: [productId], references: [id], onDelete: Cascade)
//   productId Int

//   createdAt DateTime @default(now())

//   @@unique([userId, productId]) // Ù…Ø³ØªØ®Ø¯Ù… Ù…Ø§ ÙŠØ¶ÙŠÙ Ù†ÙØ³ Ø§Ù„Ù…Ù†ØªØ¬ Ù…Ø±ØªÙŠÙ†
// }
model Wishlist {
  id        Int     @id @default(autoincrement())
  user      User    @relation(fields: [userId], references: [id], onDelete: Cascade)
  userId    Int
  product   Product @relation(fields: [productId], references: [id], onDelete: Cascade)
  productId Int

  createdAt DateTime @default(now())

  @@unique([userId, productId])
}

1- Ù‚Ù…Øª Ø¨Ø§Ø¶Ø§ÙØ© Ù…ÙŠØ²Ø© ØªÙØ¹ÙŠÙ„ Ø§Ù„Ø­Ø³Ø§Ø¨ Ø¨Ø§Ø³ØªØ®Ø¯Ø§Ù… email Ø¨Ø§Ù„Ø§Ø¶Ø§ÙØ© Ø§Ù„Ù‰ Ø§Ù…ÙƒØ§Ù†ÙŠØ© ØªØºÙŠØ± ÙƒÙ„Ù…Ø© Ø§Ù„Ù…Ø±ÙˆØ±
Ù‡Ø°Ù‡ Ù‡ÙŠ Ø§Ù„Ù…Ù„ÙØ§Øª Ø§Ù„Ù…Ø³Ø¤ÙˆÙ„Ø© Ø¹Ù† Ù‡Ø°Ù‡ Ø§Ù„ØªØ¹Ø¯ÙŠÙ„Ø§Øª
utils/sendEmail.js
import nodemailer from "nodemailer";

const transporter = nodemailer.createTransport({
  service: "gmail", // Ø£Ùˆ smtp provider
  auth: {
    user: process.env.EMAIL_USER,
    pass: process.env.EMAIL_PASS,
  },
});

export default async function sendEmail(to, subject, text) {
  await transporter.sendMail({
    from: process.env.EMAIL_USER,
    to,
    subject,
    text,
  });
}

service/userService.js
import prisma from "../config/db.js";
import bcrypt from "bcrypt";
import jwt from "jsonwebtoken";
import { CustomResponse, ResponseStatus } from "../utils/customResponse.js";
import crypto from "crypto";
import sendEmail from "../utils/sendEmail.js"; // ØªØ­ØªØ§Ø¬ ØªØ¹Ù…Ù„ util Ù„Ø¥Ø±Ø³Ø§Ù„ Ø§Ù„Ø¨Ø±ÙŠØ¯

export const register = async ({
  name,
  email,
  password,
  role = "CUSTOMER",
}) => {
  if (await prisma.user.findUnique({ where: { email } }))
    throw new CustomResponse(ResponseStatus.FORBIDDEN, "Email already in use");

  const hashedPassword = await bcrypt.hash(password, 10);

  const verificationToken = crypto.randomBytes(32).toString("hex");
  const verificationTokenExpires = new Date(Date.now() + 60 * 60 * 1000); // Ø³Ø§Ø¹Ø© ÙˆØ§Ø­Ø¯Ø©

  const user = await prisma.user.create({
    data: {
      name,
      email,
      password: hashedPassword,
      role,
      verificationToken,
      verificationTokenExpires,
    },
  });

  const verificationUrl = `${process.env.FRONTEND_URL}/verify-email/${verificationToken}`;

  await sendEmail(
    email,
    "Verify Your Account",
    `Click here to verify your account: ${verificationUrl}`
  );

  return user;
};

export const verifyEmail = async (token) => {
  const user = await prisma.user.findFirst({
    where: { verificationToken: token },
  });

  if (!user) {
    // check Ù„Ùˆ Ø§Ù„Ø­Ø³Ø§Ø¨ Ù…ØªÙØ¹Ù„ Ù…Ø³Ø¨Ù‚Ù‹Ø§ Ù„ÙƒÙ† Ø§Ù„ØªÙˆÙƒÙ† null
    const alreadyUser = await prisma.user.findFirst({
      where: { isVerified: true },
    });

    if (alreadyUser) {
      return { alreadyVerified: true, message: "Account already verified" };
    }

    throw new CustomResponse(
      ResponseStatus.NOT_FOUND,
      "Invalid or expired token"
    );
  }

  if (user.isVerified) {
    return { alreadyVerified: true, message: "Account already verified" };
  }

  if (user.verificationTokenExpires < new Date()) {
    throw new CustomResponse(ResponseStatus.FORBIDDEN, "Token expired");
  }

  const updatedUser = await prisma.user.update({
    where: { id: user.id },
    data: {
      isVerified: true,
      verificationToken: null,
      verificationTokenExpires: null,
    },
  });

  return updatedUser;
};

// export const verifyEmail = async (token) => {
//   const user = await prisma.user.findFirst({
//     where: { verificationToken: token },
//   });

//   if (!user) throw new Error("Invalid or expired token");

//   const updatedUser = await prisma.user.update({
//     where: { id: Number(user.id) },
//     data: {
//       isVerified: true,
//       verificationToken: null,
//     },
//   });

//   console.log("âœ… Updated User:", updatedUser);
//   return updatedUser;
// };

export const resendVerificationEmail = async (email) => {
  const user = await prisma.user.findUnique({ where: { email } });

  if (!user) {
    throw new Error("User not found");
  }

  if (user.isVerified) {
    throw new Error("Account already verified");
  }

  // ğŸ”‘ Ø¥Ù†Ø´Ø§Ø¡ ØªÙˆÙƒÙ† Ø¬Ø¯ÙŠØ¯
  const verificationToken = crypto.randomBytes(32).toString("hex");

  // ØªØ­Ø¯ÙŠØ« Ø§Ù„Ù…Ø³ØªØ®Ø¯Ù… Ø¨Ø§Ù„ØªÙˆÙƒÙ† Ø§Ù„Ø¬Ø¯ÙŠØ¯ ÙˆØµÙ„Ø§Ø­ÙŠØªÙ‡
  await prisma.user.update({
    where: { id: user.id },
    data: {
      verificationToken,
      verificationTokenExpires: new Date(Date.now() + 24 * 60 * 60 * 1000), // 24h
    },
  });

  // ğŸ”— Ø±Ø§Ø¨Ø· Ø§Ù„ØªÙØ¹ÙŠÙ„
  const verificationUrl = `${process.env.FRONTEND_URL}/verify-email/${verificationToken}`;

  // âœ‰ï¸ Ø¥Ø±Ø³Ø§Ù„ Ø§Ù„Ø¥ÙŠÙ…ÙŠÙ„
  await sendEmail({
    to: user.email,
    subject: "Verify Your Email (Resent Link)",
    html: `<p>Please verify your email by clicking the link below:</p>
           <a href="${verificationUrl}">${verificationUrl}</a>`,
  });

  return { message: "Verification email resent successfully" };
};

export const requestPasswordReset = async (email) => {
  const user = await prisma.user.findUnique({ where: { email } });
  if (!user) throw new Error("User not found");

  const resetToken = crypto.randomBytes(32).toString("hex");
  const expires = new Date(Date.now() + 3600000); // Ø³Ø§Ø¹Ø© ØµÙ„Ø§Ø­ÙŠØ©

  await prisma.user.update({
    where: { id: user.id },
    data: {
      resetPasswordToken: resetToken,
      resetPasswordExpires: expires,
    },
  });

  const resetUrl = `${process.env.FRONTEND_URL}/reset-password/${resetToken}`;
  await sendEmail(
    email,
    "Reset Password",
    `Reset your password here: ${resetUrl}`
  );

  return true;
};

export const resetPassword = async (token, newPassword) => {
  const user = await prisma.user.findFirst({
    where: {
      resetPasswordToken: token,
      resetPasswordExpires: { gt: new Date() },
    },
  });

  if (!user) throw new Error("Invalid or expired token");

  const hashedPassword = await bcrypt.hash(newPassword, 10);

  await prisma.user.update({
    where: { id: user.id },
    data: {
      password: hashedPassword,
      resetPasswordToken: null,
      resetPasswordExpires: null,
    },
  });

  return true;
};

// old register
export const register1 = async ({
  name,
  email,
  password,
  role = "CUSTOMER",
}) => {
  if (email === (await prisma.user.findUnique({ where: { email } }))?.email)
    throw new CustomResponse(
      ResponseStatus.FORBIDDEN,
      "This email is Already used"
    );

  const hashedPassword = await bcrypt.hash(password, 10);
  const user = await prisma.user.create({
    data: { name, email, password: hashedPassword, role },
  });
  return user;
};

export const login = async ({ email, password }) => {
  const user = await prisma.user.findUnique({ where: { email } });
  if (!user) throw new Error("User not found");
  //CustomResponse(ResponseStatus.NOT_FOUND, "User not found");

  const isMatch = await bcrypt.compare(password, user.password);
  if (!isMatch) throw new Error("Invalid credentials");

  const token = jwt.sign(
    { userId: user.id, role: user.role },
    process.env.JWT_SECRET,
    {
      expiresIn: "7d",
    }
  );

  return { user, token };
};

export const getProfile = async (userId) => {
  return await prisma.user.findUnique({
    where: { id: userId },
    include: { addresses: true },
  });
};

ccontrollers/userContoller.js
import * as userService from "../services/userService.js";
import { ResponseStatus, CustomResponse } from "../utils/customResponse.js";

export const register = async (req, res, next) => {
  try {
    const user = await userService.register(req.body);
    res
      .status(ResponseStatus.RESOURCE_CREATED.code)
      .json(
        new CustomResponse(
          ResponseStatus.RESOURCE_CREATED,
          "User Registered, please verify your email!",
          user
        )
      );
  } catch (error) {
    next(error);
  }
};

export const login = async (req, res, next) => {
  try {
    const { user, token } = await userService.login(req.body);

    if (!user.isVerified) {
      return res
        .status(ResponseStatus.FORBIDDEN.code)
        .json(
          new CustomResponse(
            ResponseStatus.FORBIDDEN,
            "Please verify your email before login"
          )
        );
    }

    res.status(ResponseStatus.OK.code).json(
      new CustomResponse(ResponseStatus.OK, "Login Successfully", {
        user,
        token,
      })
    );
  } catch (error) {
    next(error);
  }
};

export const verifyEmail = async (req, res, next) => {
  try {
    const token = req.params.token;
    const result = await userService.verifyEmail(token);

    if (result.alreadyVerified) {
      return res
        .status(ResponseStatus.OK.code)
        .json(new CustomResponse(ResponseStatus.OK, result.message, null));
    }

    res
      .status(ResponseStatus.OK.code)
      .json(
        new CustomResponse(
          ResponseStatus.OK,
          "Email verified successfully!",
          result
        )
      );
  } catch (error) {
    next(error);
  }
};

export const resendVerificationEmail = async (req, res) => {
  try {
    const { email } = req.body;
    const result = await userService.resendVerificationEmail(email);

    return res
      .status(ResponseStatus.OK.code)
      .json(new CustomResponse(ResponseStatus.OK, result.message));
  } catch (error) {
    return res
      .status(ResponseStatus.BAD_REQUEST.code)
      .json(
        new CustomResponse(
          ResponseStatus.BAD_REQUEST,
          error.message || "Unable to resend verification email"
        )
      );
  }
};

export const requestPasswordReset = async (req, res, next) => {
  try {
    await userService.requestPasswordReset(req.body.email);
    res
      .status(ResponseStatus.OK.code)
      .json(
        new CustomResponse(ResponseStatus.OK, "Password reset email sent!")
      );
  } catch (error) {
    next(error);
  }
};

export const resetPassword = async (req, res, next) => {
  try {
    await userService.resetPassword(req.params.token, req.body.password);
    res
      .status(ResponseStatus.OK.code)
      .json(
        new CustomResponse(ResponseStatus.OK, "Password reset successful!")
      );
  } catch (error) {
    next(error);
  }
};

export const getProfile = async (req, res, next) => {
  try {
    const user = await userService.getProfile(req.user.userId);
    res.status(ResponseStatus.OK.code).json(user);
  } catch (error) {
    next(error);
  }
};

routes/userRoutes.js
import { Router } from "express";
import * as userController from "../controllers/userController.js";
import { auth, isAdmin } from "../middlewares/authMiddleware.js";

const router = Router();

// Register + Login
router.post("/register", userController.register);
router.post("/login", userController.login);

// Email Verification
router.get("/verify-email/:token", userController.verifyEmail);

// Password Reset
router.post("/request-password-reset", userController.requestPasswordReset);
router.post("/request-password-reset", userController.requestPasswordReset);
router.post("/reset-password/:token", userController.resetPassword);

// ğŸ”„ Ø¥Ø¹Ø§Ø¯Ø© Ø¥Ø±Ø³Ø§Ù„ Ø±Ø§Ø¨Ø· Ø§Ù„ØªÙØ¹ÙŠÙ„
router.post("/resend-verification", userController.resendVerificationEmail);

// Profile
router.get("/profile", auth, userController.getProfile);

export default router;

2- Ø§Ù…ÙƒØ§Ù†ÙŠØ© Ø§Ø¶Ø§ÙØ© Ø¹Ø¯Ø© ØµÙˆØ± Ù„ÙƒÙ„ Ù…Ù†ØªØ¬ Ø¨Ø§Ø³ØªØ®Ø¯Ø§Ù… Cloudinary and multer
config/Cloudinary.js
import { v2 as cloudinary } from "cloudinary";

cloudinary.config({
  cloud_name: process.env.CLOUDINARY_CLOUD_NAME,
  api_key: process.env.CLOUDINARY_API_KEY,
  api_secret: process.env.CLOUDINARY_API_SECRET, // Ù„Ø§Ø²Ù… ÙŠÙƒÙˆÙ† Ù…ÙˆØ¬ÙˆØ¯ Ù„Ù„Ø³ÙŠØ±ÙØ±
});

export default cloudinary;

productsService.js

import prisma from "../config/db.js";
import slugify from "slugify";
import cloudinary from "../config/cloudinary.js";

export const getProducts = async (query) => {
  const {
    page = 1,
    limit = 10,
    search,
    categoryId,
    minPrice,
    maxPrice,
    sortBy = "createdAt",
    order = "desc",
    inStock,
  } = query;

  const skip = (page - 1) * limit;
  const take = parseInt(limit);

  // âœ… Ø¨Ù†Ø§Ø¡ Ø´Ø±ÙˆØ· Ø§Ù„Ø¨Ø­Ø«
  const where = {
    AND: [
      search
        ? {
            OR: [
              { title: { contains: search } },
              { description: { contains: search } },
            ],
          }
        : {},
      categoryId ? { categoryId: Number(categoryId) } : {},
      minPrice ? { price: { gte: parseFloat(minPrice) } } : {},
      maxPrice ? { price: { lte: parseFloat(maxPrice) } } : {},
      inStock === "true" ? { stock: { gt: 0 } } : {},
    ],
  };

  // âœ… Ø¹Ø¯Ø¯ Ø§Ù„Ù…Ù†ØªØ¬Ø§Øª
  const total = await prisma.product.count({ where });

  // âœ… Ø§Ù„Ù…Ù†ØªØ¬Ø§Øª
  const products = await prisma.product.findMany({
    where,
    skip,
    take,
    orderBy: { [sortBy]: order },
    include: {
      category: true,
      images: true,
    },
  });

  return {
    page: Number(page),
    limit: take,
    total,
    totalPages: Math.ceil(total / take),
    products,
  };
};

export const getAllProducts = async (filters = {}) => {
  return await prisma.product.findMany({
    where: filters,
    include: { category: true, images: true },
  });
};

export const getProductById = async (id) => {
  return await prisma.product.findUnique({
    where: { id: Number(id) },
    include: { category: true, images: true },
  });
};

export const createProduct = async (data, files) => {
  const { title, description, price, stock, categoryId } = data;

  const slug = slugify(title, { lower: true, strict: true });

  // Ø§Ø±ÙØ¹ Ø§Ù„ØµÙˆØ± Ø¹Ù„Ù‰ Cloudinary
  const uploadPromises = files.map((file) =>
    cloudinary.uploader
      .upload_stream({ folder: "products" }, (error, result) => {
        if (error) throw error;
        return result.secure_url;
      })
      .end(file.buffer)
  );

  // âš¡ï¸ Ù„Ø§Ø²Ù… Ù†Ø­ÙˆÙ„ Ø§Ù„Ù€ stream Ù„ÙˆØ¹ÙˆØ¯ (Promises)
  const urls = await Promise.all(
    files.map(
      (file) =>
        new Promise((resolve, reject) => {
          const stream = cloudinary.uploader.upload_stream(
            { folder: "products" },
            (error, result) => {
              if (error) reject(error);
              else resolve(result.secure_url);
            }
          );
          stream.end(file.buffer);
        })
    )
  );

  // Ø£Ù†Ø´Ø¦ Ø§Ù„Ù…Ù†ØªØ¬
  const product = await prisma.product.create({
    data: {
      title,
      slug,
      description,
      price: parseFloat(price),
      stock: parseInt(stock),
      categoryId: categoryId ? parseInt(categoryId) : null,
      // Ø®Ø²Ù† Ø§Ù„ØµÙˆØ± ÙÙŠ Ø¬Ø¯ÙˆÙ„ Ù…Ù†ÙØµÙ„ Ù„Ùˆ Ø¹Ù†Ø¯Ùƒ ProductImage
      images: {
        create: urls.map((url) => ({ url })),
      },
    },
    include: { images: true },
  });

  return product;
};

export const updateProduct = async (id, data, files) => {
  const { title, description, price, stock, categoryId } = data;

  // Ù„Ùˆ ÙÙŠÙ‡ title Ø¬Ø¯ÙŠØ¯ØŒ Ø§Ø¹Ù…Ù„ slug
  const slug = title
    ? slugify(title, { lower: true, strict: true })
    : undefined;

  // 1ï¸âƒ£ Ø§Ø±ÙØ¹ Ø§Ù„ØµÙˆØ± Ø§Ù„Ø¬Ø¯ÙŠØ¯Ø© Ù„Ùˆ Ù…ÙˆØ¬ÙˆØ¯Ø©
  let newImages = [];
  if (files && files.length > 0) {
    newImages = await Promise.all(
      files.map(
        (file) =>
          new Promise((resolve, reject) => {
            const stream = cloudinary.uploader.upload_stream(
              { folder: "products" },
              (error, result) => {
                if (error) reject(error);
                else resolve({ url: result.secure_url });
              }
            );
            stream.end(file.buffer);
          })
      )
    );
  }

  // 2ï¸âƒ£ Ø§Ø­Ø°Ù Ø§Ù„ØµÙˆØ± Ø§Ù„Ù‚Ø¯ÙŠÙ…Ø© (Ù„Ùˆ Ø¹Ø§ÙŠØ² ØªØ­Ø°ÙÙ‡Ø§ ÙØ¹Ù„ÙŠÙ‹Ø§ Ù…Ù† Cloudinary ÙƒÙ…Ø§Ù†)
  if (newImages.length > 0) {
    const oldImages = await prisma.productImage.findMany({
      where: { productId: Number(id) },
    });

    // Ø§Ø­Ø°Ù Ù…Ù† Cloudinary (Ø§Ø®ØªÙŠØ§Ø±ÙŠ)
    for (const img of oldImages) {
      const publicId = img.url.split("/").pop().split(".")[0]; // Ø§Ø³ØªØ®Ø±Ø¬ public_id Ù…Ù† Ø§Ù„Ø±Ø§Ø¨Ø·
      try {
        await cloudinary.uploader.destroy(`products/${publicId}`);
      } catch (err) {
        console.error("âŒ Failed to delete from Cloudinary:", err.message);
      }
    }

    // Ø§Ù…Ø³Ø­ Ù…Ù† DB
    await prisma.productImage.deleteMany({
      where: { productId: Number(id) },
    });
  }

  // 3ï¸âƒ£ Ø­Ø¯Ø« Ø¨ÙŠØ§Ù†Ø§Øª Ø§Ù„Ù…Ù†ØªØ¬
  const updatedProduct = await prisma.product.update({
    where: { id: Number(id) },
    data: {
      title,
      slug,
      description,
      price: price ? parseFloat(price) : undefined,
      stock: stock ? parseInt(stock) : undefined,
      categoryId: categoryId ? Number(categoryId) : undefined,
      ...(newImages.length > 0 && {
        images: {
          create: newImages, // Ø§Ù„ØµÙˆØ± Ø§Ù„Ø¬Ø¯ÙŠØ¯Ø©
        },
      }),
    },
    include: { images: true },
  });

  return updatedProduct;
};

export const updateProductWithoutDeleteOldImage = async (id, data, files) => {
  const { title, description, price, stock, categoryId } = data;

  // slug Ø¬Ø¯ÙŠØ¯ Ù„Ùˆ Ø§Ù„Ø¹Ù†ÙˆØ§Ù† Ø§ØªØºÙŠØ±
  const slug = title
    ? slugify(title, { lower: true, strict: true })
    : undefined;

  // 1ï¸âƒ£ Ø§Ø±ÙØ¹ Ø§Ù„ØµÙˆØ± Ø§Ù„Ø¬Ø¯ÙŠØ¯Ø© Ù„Ùˆ Ù…ÙˆØ¬ÙˆØ¯Ø©
  let newImages = [];
  if (files && files.length > 0) {
    newImages = await Promise.all(
      files.map(
        (file) =>
          new Promise((resolve, reject) => {
            const stream = cloudinary.uploader.upload_stream(
              { folder: "products" },
              (error, result) => {
                if (error) reject(error);
                else resolve({ url: result.secure_url });
              }
            );
            stream.end(file.buffer);
          })
      )
    );
  }

  // 2ï¸âƒ£ Ø­Ø¯Ø« Ø¨ÙŠØ§Ù†Ø§Øª Ø§Ù„Ù…Ù†ØªØ¬ + Ø£Ø¶Ù Ø§Ù„ØµÙˆØ± Ø§Ù„Ø¬Ø¯ÙŠØ¯Ø© (Ù„Ùˆ ÙÙŠÙ‡)
  const updatedProduct = await prisma.product.update({
    where: { id: Number(id) },
    data: {
      title,
      slug,
      description,
      price: price ? parseFloat(price) : undefined,
      stock: stock ? parseInt(stock) : undefined,
      categoryId: categoryId ? Number(categoryId) : undefined,
      ...(newImages.length > 0 && {
        images: {
          create: newImages, // ÙŠØ¶ÙŠÙ Ø§Ù„ØµÙˆØ± Ø§Ù„Ø¬Ø¯ÙŠØ¯Ø© Ø¬Ù†Ø¨ Ø§Ù„Ù‚Ø¯ÙŠÙ…Ø©
        },
      }),
    },
    include: { images: true },
  });

  return updatedProduct;
};

export const deleteProduct = async (id) => {
  // 1ï¸âƒ£ Ù‡Ø§Øª Ø§Ù„ØµÙˆØ± Ø§Ù„Ù…Ø±ØªØ¨Ø·Ø© Ø¨Ø§Ù„Ù…Ù†ØªØ¬
  const product = await prisma.product.findUnique({
    where: { id: Number(id) },
    include: { images: true },
  });

  if (!product) {
    throw new Error("âŒ Product not found");
  }

  // 2ï¸âƒ£ Ø§Ù…Ø³Ø­ Ø§Ù„ØµÙˆØ± Ù…Ù† Cloudinary
  for (const img of product.images) {
    try {
      // Ø§Ø³ØªØ®Ø±Ø¬ public_id Ù…Ù† Ø±Ø§Ø¨Ø· Ø§Ù„ØµÙˆØ±Ø©
      const publicId = img.url.split("/").pop().split(".")[0];
      await cloudinary.uploader.destroy(`products/${publicId}`);
    } catch (err) {
      console.error("âš ï¸ Failed to delete image from Cloudinary:", err.message);
    }
  }

  // 3ï¸âƒ£ Ø§Ù…Ø³Ø­ Ø§Ù„Ù…Ù†ØªØ¬ (Ù…Ø¹ Ø§Ù„ØµÙˆØ± Ù…Ù† DB)
  const deletedProduct = await prisma.product.delete({
    where: { id: Number(id) },
  });

  return deletedProduct;
};

controllers/productContoller.js
import * as productService from "../services/productService.js";
import { CustomResponse, ResponseStatus } from "../utils/customResponse.js";

export const getProducts = async (req, res, next) => {
  try {
    const products = await productService.getProducts(req.query);
    res
      .status(ResponseStatus.OK.code)
      .json(new CustomResponse(ResponseStatus.OK, "Products", { ...products }));
  } catch (error) {
    next(error);
  }
};

export const getProduct = async (req, res, next) => {
  try {
    const product = await productService.getProductById(req.params.id);
    if (!product)
      return res
        .status(ResponseStatus.NOT_FOUND.code)
        .json(new CustomResponse(ResponseStatus.NOT_FOUND, "Not Found!"));
    res
      .status(ResponseStatus.OK.code)
      .json(new CustomResponse(ResponseStatus.OK, "Product", product));
  } catch (error) {
    next(error);
  }
};

export const createProduct = async (req, res, next) => {
  try {
    const product = await productService.createProduct(req.body, req.files);

    res
      .status(ResponseStatus.RESOURCE_CREATED.code)
      .json(
        new CustomResponse(
          ResponseStatus.RESOURCE_CREATED,
          "Product Created Successfully!",
          product
        )
      );
  } catch (error) {
    next(error);
  }
};
export const updateProduct = async (req, res, next) => {
  try {
    const product = await productService.updateProduct(
      req.params.id,
      req.body,
      req.files
    );
    res
      .status(ResponseStatus.OK.code)
      .json(
        new CustomResponse(
          ResponseStatus.OK,
          "Success Update a Producct",
          product
        )
      );
  } catch (error) {
    next(error);
  }
};

export const deleteProduct = async (req, res, next) => {
  try {
    await productService.deleteProduct(req.params.id);
    res.json(new CustomResponse(ResponseStatus.OK, "Deleted"));
  } catch (error) {
    next(error);
  }
};

middlewares/upload.js
// import multer from "multer";
// import { CloudinaryStorage } from "multer-storage-cloudinary";
// import cloudinary from "../config/cloudinary.js";

// const storage = new CloudinaryStorage({
//   cloudinary,
//   params: {
//     folder: "ecommerce_products", // Ù…Ø¬Ù„Ø¯ Ø¹Ù„Ù‰ Cloudinary
//     allowed_formats: ["jpg", "png", "jpeg", "webp"],
//   },
// });

import multer from "multer";

// Ù†Ø®Ø²Ù† ÙÙŠ Ø§Ù„Ø°Ø§ÙƒØ±Ø© (buffer) Ø¹Ø´Ø§Ù† Ù†Ø±ÙØ¹Ù‡Ø§ Ù…Ø¨Ø§Ø´Ø±Ø© Ù„Ù€ Cloudinary
const storage = multer.memoryStorage();

export const upload = multer({
  storage,
  limits: { fileSize: 5 * 1024 * 1024 }, // 5MB Ù„ÙƒÙ„ ØµÙˆØ±Ø©
});


routes/productRoutes.js
import { Router } from "express";
import { auth, isAdmin } from "../middlewares/authMiddleware.js";
import * as productController from "../controllers/productController.js";
import { productValidator } from "../validators/index.js";
import { validate } from "../middlewares/validationRequest.js";
import { upload } from "../middlewares/upload.js";

// Ø¥Ø¶Ø§ÙØ© Ù…Ù†ØªØ¬ Ù…Ø¹ ØµÙˆØ±Ø©

const router = Router();

router.get("/", productController.getProducts);
router.get("/:id", productController.getProduct);
router.post(
  "/add",
  auth,
  isAdmin,
  upload.array("images", 5), // Ø±ÙØ¹ Ø­ØªÙ‰ 5 ØµÙˆØ±
  productValidator,
  validate,
  productController.createProduct
);
router.put(
  "/update/:id",
  auth,
  isAdmin,
  upload.array("images", 5), // Ø±ÙØ¹ Ø­ØªÙ‰ 5 ØµÙˆØ±
  productValidator,
  validate,
  productController.updateProduct
);
router.delete("/delete/:id", auth, isAdmin, productController.deleteProduct);

export default router;

3- Ø§Ø¶ÙØª Ù…ÙŠØ²Ø© reviews and rating Ù„Ù„Ù…Ù†ØªØ¬Ø§Øª
service/reviewService.js
import prisma from "../config/db.js";

export const addReview = async (userId, productId, { rating, comment }) => {
  // ØªØ­Ù‚Ù‚ Ø¥Ø°Ø§ ÙƒØ§Ù† Ø§Ù„Ù…Ø³ØªØ®Ø¯Ù… Ù‚ÙŠÙ‘Ù… Ø§Ù„Ù…Ù†ØªØ¬ Ù…Ù† Ù‚Ø¨Ù„
  const existingReview = await prisma.review.findUnique({
    where: { productId_userId: { productId, userId } },
  });

  if (existingReview) {
    throw new Error("You already reviewed this product");
  }

  // Ø¥Ø¶Ø§ÙØ© Ù…Ø±Ø§Ø¬Ø¹Ø© Ø¬Ø¯ÙŠØ¯Ø©
  const review = await prisma.review.create({
    data: {
      rating,
      comment,
      productId,
      userId,
    },
  });

  // ØªØ­Ø¯ÙŠØ« Ù…ØªÙˆØ³Ø· Ø§Ù„ØªÙ‚ÙŠÙŠÙ…
  await updateProductAvgRating(productId);

  return review;
};

export const updateReview = async (userId, productId, { rating, comment }) => {
  const review = await prisma.review.update({
    where: { productId_userId: { productId, userId } },
    data: { rating, comment },
  });

  await updateProductAvgRating(productId);
  return review;
};

export const deleteReview = async (userId, productId) => {
  await prisma.review.delete({
    where: { productId_userId: { productId, userId } },
  });

  await updateProductAvgRating(productId);
  return true;
};

export const getProductReviews = async (productId) => {
  return await prisma.review.findMany({
    where: { productId },
    include: {
      user: { select: { id: true, name: true } },
    },
    orderBy: { createdAt: "desc" },
  });
};

const updateProductAvgRating = async (productId) => {
  const result = await prisma.review.aggregate({
    where: { productId },
    _avg: { rating: true },
  });

  await prisma.product.update({
    where: { id: productId },
    data: { avgRating: result._avg.rating || 0 },
  });
};

controllers/reviewController.js
import * as reviewService from "../services/reviewService.js";
import { CustomResponse, ResponseStatus } from "../utils/customResponse.js";

export const addReview = async (req, res, next) => {
  try {
    const { productId, rating, comment } = req.body;
    const review = await reviewService.addReview(req.user.userId, productId, {
      rating,
      comment,
    });

    res
      .status(ResponseStatus.RESOURCE_CREATED.code)
      .json(
        new CustomResponse(
          ResponseStatus.RESOURCE_CREATED,
          "Review added successfully",
          review
        )
      );
  } catch (err) {
    next(err);
  }
};

export const updateReview = async (req, res, next) => {
  try {
    const { productId, rating, comment } = req.body;
    const review = await reviewService.updateReview(
      req.user.userId,
      productId,
      {
        rating,
        comment,
      }
    );

    res.json(
      new CustomResponse(
        ResponseStatus.OK,
        "Review updated successfully",
        review
      )
    );
  } catch (err) {
    next(err);
  }
};

export const deleteReview = async (req, res, next) => {
  try {
    const { productId } = req.body;
    await reviewService.deleteReview(req.user.userId, productId);

    res.json(
      new CustomResponse(ResponseStatus.OK, "Review deleted successfully")
    );
  } catch (err) {
    next(err);
  }
};

export const getProductReviews = async (req, res, next) => {
  try {
    const { productId } = req.params;
    const reviews = await reviewService.getProductReviews(Number(productId));

    res.json(
      new CustomResponse(
        ResponseStatus.OK,
        "Reviews fetched successfully",
        reviews
      )
    );
  } catch (err) {
    next(err);
  }
};

routes/reviewRoutes.js
import { Router } from "express";
import * as reviewController from "../controllers/reviewController.js";
import { auth } from "../middlewares/authMiddleware.js";

const router = Router();

// Ø¥Ø¶Ø§ÙØ© Ù…Ø±Ø§Ø¬Ø¹Ø©
router.post("/add", auth, reviewController.addReview);

// ØªØ¹Ø¯ÙŠÙ„ Ù…Ø±Ø§Ø¬Ø¹Ø©
router.put("/update", auth, reviewController.updateReview);

// Ø­Ø°Ù Ù…Ø±Ø§Ø¬Ø¹Ø©
router.delete("/delete", auth, reviewController.deleteReview);

// Ø¬Ù„Ø¨ Ù…Ø±Ø§Ø¬Ø¹Ø§Øª Ø§Ù„Ù…Ù†ØªØ¬
router.get("/product/:productId", reviewController.getProductReviews);

export default router;

4- wishlist Ù„Ù„Ù…Ø³ØªØ®Ø¯Ù…

services/wishlistService.js
import prisma from "../config/db.js";

export async function addToWishlist(userId, productId) {
  return prisma.wishlist.create({
    data: { userId, productId },
  });
}

export async function removeFromWishlist(userId, productId) {
  return prisma.wishlist.deleteMany({
    where: { userId, productId },
  });
}

export async function getWishlist(userId) {
  return prisma.wishlist.findMany({
    where: { userId },
    include: { product: true },
  });
}

controllers/wishlistController.js
import * as wishlistService from "../services/wishlistService.js";
import { CustomResponse, ResponseStatus } from "../utils/customResponse.js";

export const addWishlist = async (req, res, next) => {
  try {
  
    const result = await wishlistService.addToWishlist(
      req.user.userId, // ğŸ‘ˆ Ù…Ù† JWT Ø£Ùˆ session
      req.body.productId
    );
    res
      .status(ResponseStatus.RESOURCE_CREATED.code)
      .json(
        new CustomResponse(
          ResponseStatus.RESOURCE_CREATED,
          "item added to wishlist",
          result
        )
      );
  } catch (error) {
    next(error);
  }
};

export const removeWishlist = async (req, res, next) => {
  try {
    await wishlistService.removeFromWishlist(
      req.user.id,
      parseInt(req.params.productId)
    );
    res.json(new CustomResponse(ResponseStatus.OK, "Removed from wishlist"));
  } catch (error) {
    next(error);
  }
};

export const getWishlist = async (req, res, next) => {
  try {
    const wishlist = await wishlistService.getWishlist(req.user.id);
    res.json(new CustomResponse(ResponseStatus.OK, "wishlist", wishlist));
  } catch (error) {
    next(error);
  }
};

routes/wishlistRoutes.js
import express from "express";
import {
  addWishlist,
  removeWishlist,
  getWishlist,
} from "../controllers/wishlistController.js";
import { isCustomer, auth } from "../middlewares/authMiddleware.js";

const router = express.Router();

router.post("/", auth, isCustomer, addWishlist);
router.delete("/:productId", auth, isCustomer, removeWishlist);
router.get("/", auth, isCustomer, getWishlist);

export default router;

4- Ø¹Ø¯Ù„Øª middlewares/authMiddleware.js
import jwt from "jsonwebtoken";
import { CustomResponse, ResponseStatus } from "../utils/customResponse.js";

export const auth = (req, res, next) => {
  const authHeader = req.headers["authorization"];
  if (!authHeader)
    return res
      .status(ResponseStatus.UNAUTHORIZED.code)
      .json(
        new CustomResponse(ResponseStatus.UNAUTHORIZED, "No token provided")
      );

  const token = authHeader.split(" ")[1]; // Bearer <token>
  //{ error: "Invalid token format" }
  if (!token)
    return res
      .status(ResponseStatus.UNAUTHORIZED.code)
      .json(
        new CustomResponse(ResponseStatus.UNAUTHORIZED, "Invalid token format")
      );

  try {
    const decoded = jwt.verify(token, process.env.JWT_SECRET);
    req.user = decoded; // { userId, role }
    //console.log(decoded);
    next();
  } catch (error) {
    return res
      .status(ResponseStatus.FORBIDDEN.code)
      .json(
        new CustomResponse(ResponseStatus.FORBIDDEN, "Invalid or expired token")
      );

    //{ error: "Invalid or expired token" }
  }
};

export const isAdmin = (req, _res, next) => {
  if (req.user.role !== "ADMIN") {
    return _res
      .status(ResponseStatus.FORBIDDEN.code)
      .json(
        new CustomResponse(ResponseStatus.FORBIDDEN, "Admin access required")
      );
  }
  next();
};

export const isCustomer = (req, res, next) => {
  if (req.user.role !== "CUSTOMER") {
    new CustomResponse(ResponseStatus.FORBIDDEN, "Customer access required");
  }
  next();
};

